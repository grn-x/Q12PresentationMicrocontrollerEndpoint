<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Interactive Debugging CTF</title>
  <style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem auto;
    max-width: 1200px;
    background: #f9f9f9;
    padding: 1rem 2rem;
    border-radius: 8px;
    box-shadow: 0 0 12px #ccc;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
    color: #333;
  }
  h2 {
    border-bottom: 2px solid #333;
    padding-bottom: 0.3rem;
    margin-bottom: 1rem;
  }
  .challenges {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1.5rem;
  }
  .challenge {
    background: #fff;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 0 8px #ccc;
    border-left: 4px solid #007acc;
  }
  .challenge h3 {
    margin-top: 0;
    color: #007acc;
  }
  .snippet {
    background: #272822;
    color: #f8f8f2;
    padding: 1rem;
    border-radius: 6px;
    font-family: 'Courier New', monospace;
    white-space: pre-wrap;
    margin: 1rem 0;
    font-size: 0.9rem;
    overflow-x: auto;
  }
  .hint {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    padding: 0.8rem;
    border-radius: 4px;
    margin: 1rem 0;
    font-size: 0.9rem;
  }
  label {
    font-weight: bold;
    display: block;
    margin: 1rem 0 0.5rem 0;
  }
  input[type="text"] {
    font-family: monospace;
    padding: 0.5rem;
    width: 300px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  button {
    margin-left: 0.6rem;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #007acc;
    background-color: #007acc;
    color: white;
  }
  button:hover {
    background-color: #005a9e;
  }
  .answer {
    margin-top: 0.5rem;
    font-weight: bold;
    padding: 0.5rem;
    border-radius: 4px;
  }
  .client-info {
    background: #e8f4fd;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 2rem;
  }
  .client-info input {
    margin: 0.5rem 0;
    width: 250px;
  }
</style>
</head>
<body>
  <h1>üîç Advanced Interactive Debugging CTF</h1>
  <p>Master the art of debugging! Each challenge requires specific debugger skills. No cleartext flags - you must debug to win!</p>

  <div class="client-info">
    <label for="clientNameInput">Client Name:</label>
    <input type="text" id="clientNameInput" placeholder="Enter your name" />
    <label for="addressInput">ESP32 Server Address:</label>
    <input type="text" id="addressInput" placeholder="192.168.1.100" />
  </div>

  <div class="challenges">
    
    <!-- Challenge 1: Dynamic flag generation with timing -->
    <div class="challenge">
      <h3>Level 1: Timing is Everything</h3>
      <div class="snippet">function generateTimedFlag() {
  const timestamp = Date.now();
  const seed = timestamp % 10000;
  const flagParts = ['F', 'L', 'A', 'G', '{'];
  
  // Flag changes every second!
  for (let i = 0; i < 8; i++) {
    flagParts.push(String.fromCharCode(65 + (seed + i) % 26));
  }
  flagParts.push('}');
  
  return flagParts.join('');
}</div>
      <div class="hint">üí° Set a breakpoint inside the function and inspect the 'seed' variable when it's calculated. The flag changes every second!</div>
      <label>Enter the seed value you found:</label>
      <input type="text" id="input1" placeholder="Enter seed number" />
      <button onclick="checkAnswer('input1', 'c1')">Check</button>
      <div class="answer" id="answer1"></div>
    </div>

    <!-- Challenge 2: Conditional breakpoints -->
    <div class="challenge">
      <h3>Level 2: Conditional Debugging</h3>
      <div class="snippet">function processData() {
  for (let i = 0; i < 1000; i++) {
    const value = Math.floor(Math.random() * 100);
    const processed = transform(value);
    
    // Secret flag only appears when specific condition is met
    if (processed === 42) {
      const secretCode = btoa('HIDDEN_' + i + '_FLAG');
      console.log('Processing item:', i, 'with secret:', secretCode);
    }
  }
}

function transform(x) {
  return (x * 7 + 13) % 100;
}</div>
      <div class="hint">üí° Use a conditional breakpoint: processed === 42. Then inspect the 'secretCode' variable and decode it!</div>
      <label>Enter the decoded secret (without HIDDEN_ prefix and _FLAG suffix):</label>
      <input type="text" id="input2" placeholder="Enter the number" />
      <button onclick="checkAnswer('input2', 'c2')">Check</button>
      <div class="answer" id="answer2"></div>
    </div>

    <!-- Challenge 3: Call stack inspection -->
    <div class="challenge">
      <h3>Level 3: Call Stack Detective</h3>
      <div class="snippet">function level1(x) {
  return level2(x + 10);
}

function level2(x) {
  return level3(x * 2);
}

function level3(x) {
  const magic = level4(x - 5);
  return magic;
}

function level4(x) {
  // Breakpoint here and check call stack!
  const callStack = new Error().stack.split('\n').length;
  const flag = 'FLAG{STACK_' + callStack + '_DEEP}';
  return x + callStack;
}</div>
      <div class="hint">üí° Set a breakpoint in level4() and examine the call stack depth. Count the stack frames!</div>
      <label>Enter the complete flag with stack depth:</label>
      <input type="text" id="input3" placeholder="FLAG{STACK_X_DEEP}" />
      <button onclick="checkAnswer('input3', 'c3')">Check</button>
      <div class="answer" id="answer3"></div>
    </div>

    <!-- Challenge 4: Watch expressions -->
    <div class="challenge">
      <h3>Level 4: Watch and Learn</h3>
      <div class="snippet">function complexCalculation() {
  let a = 7;
  let b = 13;
  
  for (let i = 0; i < 5; i++) {
    a = a * b % 97;
    b = b + a % 23;
    
    // Add watch expression: a ^ b
    const xorResult = a ^ b;
    
    if (i === 3) {
      // Flag hidden in XOR operation at iteration 3
      console.log('Iteration', i, 'XOR:', xorResult);
    }
  }
}</div>
      <div class="hint">üí° Add a watch expression for 'a ^ b' and step through the loop. Find the XOR value at iteration 3!</div>
      <label>Enter the XOR result at iteration 3:</label>
      <input type="text" id="input4" placeholder="Enter XOR value" />
      <button onclick="checkAnswer('input4', 'c4')">Check</button>
      <div class="answer" id="answer4"></div>
    </div>

    <!-- Challenge 5: Memory inspection with closures -->
    <div class="challenge">
      <h3>Level 5: Closure Secrets</h3>
      <div class="snippet">function createSecretKeeper() {
  const secrets = {
    key1: 'decoy',
    key2: 'misdirection',
    hidden: null
  };
  
  // Hidden flag is computed and stored in closure
  const computeSecret = () => {
    const base = 'CLOSURE';
    const modifier = secrets.key1.length + secrets.key2.length;
    secrets.hidden = base + '_' + modifier + '_SECRET';
  };
  
  computeSecret();
  
  return {
    getHint: () => 'Check the closure scope!',
    dummy: () => secrets.key1 + secrets.key2
  };
}

const keeper = createSecretKeeper();</div>
      <div class="hint">üí° Set a breakpoint inside createSecretKeeper, then inspect the closure scope to find the 'secrets.hidden' value!</div>
      <label>Enter the hidden secret:</label>
      <input type="text" id="input5" placeholder="Enter the hidden value" />
      <button onclick="checkAnswer('input5', 'c5')">Check</button>
      <div class="answer" id="answer5"></div>
    </div>

    <!-- Challenge 6: Network debugging -->
    <div class="challenge">
      <h3>Level 6: Network Inspector</h3>
      <div class="snippet">async function fetchSecret() {
  try {
    // This will fail, but check the Network tab!
    const response = await fetch('/api/secret', {
      headers: {
        'X-Secret-Code': btoa('NETWORK_DEBUG_FLAG')
      }
    });
  } catch (error) {
    console.log('Expected error - check Network tab for headers!');
  }
}</div>
      <div class="hint">üí° Run fetchSecret() and check the Network tab. Look at the request headers and decode the X-Secret-Code!</div>
      <label>Enter the decoded header value:</label>
      <input type="text" id="input6" placeholder="Decode the header" />
      <button onclick="checkAnswer('input6', 'c6')">Check</button>
      <div class="answer" id="answer6"></div>
    </div>

    <!-- Challenge 7: Prototype manipulation -->
    <div class="challenge">
      <h3>Level 7: Prototype Detective</h3>
      <div class="snippet">function SecretClass(id) {
  this.id = id;
  this.publicData = 'visible';
}

SecretClass.prototype.getFlag = function() {
  // Flag is in prototype method
  const encoded = '0x' + (this.id * 1337).toString(16).toUpperCase();
  return 'PROTO_' + encoded + '_FLAG';
};

const instance = new SecretClass(42);</div>
      <div class="hint">üí° Set a breakpoint in the getFlag method and inspect 'this' and the prototype chain. What's the encoded value?</div>
      <label>Enter the complete flag:</label>
      <input type="text" id="input7" placeholder="PROTO_0xXXXXX_FLAG" />
      <button onclick="checkAnswer('input7', 'c7')">Check</button>
      <div class="answer" id="answer7"></div>
    </div>

  </div>

  <script>
    const NAME_KEY = 'Q12_presentation_name';
    const ADDRESS_KEY = 'Q12_presentation_address';

    const nameInput = document.getElementById('clientNameInput');
    const addressInput = document.getElementById('addressInput');

    window.addEventListener('DOMContentLoaded', () => {
      if (sessionStorage.getItem(NAME_KEY)) {
        nameInput.value = sessionStorage.getItem(NAME_KEY);
      }
      if (sessionStorage.getItem(ADDRESS_KEY)) {
        addressInput.value = sessionStorage.getItem(ADDRESS_KEY);
      }
      
      startChallenges();
    });

  nameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      sessionStorage.setItem(NAME_KEY, nameInput.value.trim());
      alert('Client name saved');
    }
  });

  addressInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      sessionStorage.setItem(ADDRESS_KEY, addressInput.value.trim());
      alert('Address saved');
    }
  });


    async function checkAnswer(inputId, challengeId) {
      const userInput = document.getElementById(inputId).value.trim();
      const answerDiv = document.getElementById("answer" + challengeId.substring(1));

      const clientName = sessionStorage.getItem(NAME_KEY) || "Anonymous";
      const espIp = sessionStorage.getItem(ADDRESS_KEY) || "127.0.0.1";

      if (!userInput) {
        answerDiv.textContent = "‚ö†Ô∏è Please enter an answer!";
        answerDiv.style.color = "orange";
        answerDiv.style.backgroundColor = "#fff3cd";
        return;
      }

      try {
        const url = `http://${espIp}/assert?name=${encodeURIComponent(clientName)}&number=${encodeURIComponent(challengeId)}&param=${encodeURIComponent(userInput)}`;
        const response = await fetch(url);

        if (!response.ok) throw new Error("ESP32 responded with error");

        const result = await response.json();

        if (result.result === true) {
          answerDiv.textContent = "‚úÖ Correct! Well done!";
          answerDiv.style.color = "white";
          answerDiv.style.backgroundColor = "green";
        } else {
          answerDiv.textContent = "‚ùå Incorrect. Debug harder!";
          answerDiv.style.color = "white";
          answerDiv.style.backgroundColor = "red";
        }
      } catch (error) {
        console.error("Error checking answer:", error);
        answerDiv.textContent = "‚ö†Ô∏è Cannot reach ESP32 server. Check address!";
        answerDiv.style.color = "orange";
        answerDiv.style.backgroundColor = "#fff3cd";
      }
    }

    // Challenge implementations
    function startChallenges() {
      // Challenge 1: Start the timed flag generator
      setInterval(() => {
        generateTimedFlag();
      }, 1000);

      // Challenge 2: Start the data processor
      setInterval(() => {
        processData();
      }, 3000);

      // Challenge 3: Trigger call stack function
      setInterval(() => {
        level1(5);
      }, 2000);

      // Challenge 4: Start complex calculation
      setInterval(() => {
        complexCalculation();
      }, 4000);

      // Challenge 5: Create secret keeper
      const keeper = createSecretKeeper();
      
      // Challenge 6: Network debugging (expose function globally)
      window.fetchSecret = fetchSecret;
      
      // Challenge 7: Create prototype instance
      window.instance = new SecretClass(42);
    }

    // Challenge 1: Timing-based flag
    function generateTimedFlag() {
      const timestamp = Date.now();
      const seed = timestamp % 10000;
      const flagParts = ['F', 'L', 'A', 'G', '{'];
      
      for (let i = 0; i < 8; i++) {
        flagParts.push(String.fromCharCode(65 + (seed + i) % 26));
      }
      flagParts.push('}');
      
      return flagParts.join('');
    }

    // Challenge 2: Conditional debugging
    function processData() {
      for (let i = 0; i < 1000; i++) {
        const value = Math.floor(Math.random() * 100);
        const processed = transform(value);
        
        if (processed === 42) {
          const secretCode = btoa('HIDDEN_' + i + '_FLAG');
          console.log('Processing item:', i, 'with secret:', secretCode);
        }
      }
    }

    function transform(x) {
      return (x * 7 + 13) % 100;
    }

    // Challenge 3: Call stack inspection
    function level1(x) {
      return level2(x + 10);
    }

    function level2(x) {
      return level3(x * 2);
    }

    function level3(x) {
      const magic = level4(x - 5);
      return magic;
    }

    function level4(x) {
      const callStack = new Error().stack.split('\n').length;
      const flag = 'FLAG{STACK_' + callStack + '_DEEP}';
      return x + callStack;
    }

    // Challenge 4: Watch expressions
    function complexCalculation() {
      let a = 7;
      let b = 13;
      
      for (let i = 0; i < 5; i++) {
        a = a * b % 97;
        b = b + a % 23;
        
        const xorResult = a ^ b;
        
        if (i === 3) {
          console.log('Iteration', i, 'XOR:', xorResult);
        }
      }
    }

    // Challenge 5: Closure secrets
    function createSecretKeeper() {
      const secrets = {
        key1: 'decoy',
        key2: 'misdirection',
        hidden: null
      };
      
      const computeSecret = () => {
        const base = 'CLOSURE';
        const modifier = secrets.key1.length + secrets.key2.length;
        secrets.hidden = base + '_' + modifier + '_SECRET';
      };
      
      computeSecret();
      
      return {
        getHint: () => 'Check the closure scope!',
        dummy: () => secrets.key1 + secrets.key2
      };
    }

    // Challenge 6: Network debugging
    async function fetchSecret() {
      try {
        const response = await fetch('/api/secret', {
          headers: {
            'X-Secret-Code': btoa('NETWORK_DEBUG_FLAG')
          }
        });
      } catch (error) {
        console.log('Expected error - check Network tab for headers!');
      }
    }

    // Challenge 7: Prototype debugging
    function SecretClass(id) {
      this.id = id;
      this.publicData = 'visible';
    }

    SecretClass.prototype.getFlag = function() {
      const encoded = '0x' + (this.id * 1337).toString(16).toUpperCase();
      return 'PROTO_' + encoded + '_FLAG';
    };
  </script>
</body>
</html>